# OSI七层模型 （理想化的模型）
- 分层的含义， 专人做专事，每一层有自己的特点 （底层是为上一层提供服务的）

## 应用层    "报文"
- 应用层  核心的数据  
- 表示层  数据表现的格式 数据怎么表述        
- 会话层  建立会话 （识别身份）

### 传输层  如何将数据传递过去    "数据段"      端口
- 传输层  怎么将数据从a -> b  定义如何将数据传递过去（丢了怎么办，数据小而多的情况下）

### 网络层  如何寻找到对方 寻址   "数据包"      ip地址 
- 网络层  链接外网的功能 （链接两个网络的）  （路由器） 寻址

### 物理层  物理设备 网卡   "数据帧"   mac地址
- 数据链路层  让局域网内的设备 能提供数据交换 （交换机）  需要通过链路层来进行中转
- 物理层  主要关心用何种方式来传递数据 （物理设备 光纤、电缆。。。） 实际的车、飞机

> 针对发请求来看一下  一般我们在使用的时候 使用的模型是4层或者五层  (装包 -》 拆包)


## IP地址 & mac地址
- ipv4   &    ipv6  (比较常见的是ipv4)   "255.255.255.255"  4 * 8  32位组成    只有43亿个  （可以划分子网）
- ipv6  由8个 16位组成   128位组成  （永远用不完）

## 唯一的可以通过mac地址来进行通信  （通过ip地址 寻找mac地址）
- C8-5B-76-98-F9-0E (固定不变的)  ip是可以变化的

## 物理设备
- 中继器  信号再生的功能
- 集线器  实现多个物理设备的互联 物理层
- 交换机  能识别 谁发送给谁  （记录每个端口对应的mac地址  发送数据不在是广播的方式）  记录每个设备对应的端口号  
- 路由器 （联网的） 网关  检测你是否要访问的是外网 （将内外ip转化成外网ip地址） 如果没有wan口的路由器就是交换机  (寻址，通过链路层来传递数据)  （识别你访问的是不是外网地址，不是外网是内外的话就不需要地址转化了）


## 协议 （规定）
三层以上的才能算作协议 （规定）

- 网络层 ip协议   arp协议（只能进行局域网的通信， 会记录ip对应的mac地址）
- 传输层 tcp  udp 典型传输层协议  
- 应用层 HTTP DNS FTP 


交换机如何工作的

我怎么知道这两个是局域网（同一个网段的）的  255.255.255.0
192.168.1.1  & 255.255.255.0      11111111.11111111.11111111.00000000   192.168.1.0
192.168.1.12  & 255.255.255.0                                           192.168.1.0

## 传输层
- tcp（面向连接的 双向通信，双工  缺点就是慢）  udp(不需要连接 面向无连接的，对方是否收到我也不关心 DNS  性能高（不适合传递大数据） 视频直播) 


三次握手（tcp是双工的要互相认证双方 （但是对方收到后和握手的操作） 合并到了一起所以是三次）
四次断开 （互相分手，但是确认分手的信息和主动断开的信息没有进行合并） 


传输的是数据段落：组成



## tcp 链接服务端握手过程  （seq=1 ack=1) 表示握手成功
- 客户端准备一个seq 序列号： 默认从0开始 
- 服务端接收到握手的信号 会在客户端的seq的基础上+1  ack=1， 也像客户端提供一个seq值 seq=0（服务端的序列号是多少）
- 客户端接收到握手的信号  在服务端提供的seq + 1  ack=1  并且用服务端的ack作为本次的seq


## tcp 传递数据
- 数据段

- 客户端发送消息：seq= 1  ack=1   push  len=5
- 服务端要接受消息： seq=1  客户端的seq + len = ack 告诉客户端你发的这五个字节已经收到了
- 服务端发送消息  seq=1  ack=6  push len=2
- 客户端收到消息后 ack = 服务seq+len  = 3   seq= 服务端的ack


ack的值等于 seq + len  本次的seq 等于上一次ack的值


ack的含义：1） 对方表示收到了  2） 我会维护这个ack这个ack代表客户端传递到（序号）哪里了



- 在seq=1 ack=1的基础上断开连接
- 客户端主动和服务端说 断开连接 seq = 1 ACK = 1
- 服务端收到了  我收到了  seq = 1   ack = 客户端的seq + 1

> 这里也可以继续的发消息 （在上面的值继续累加）

- 服务端也要说 我们断开把  seq = 1 ack=2
- 客户端收到后 在 ack = 服务端的seq + 1    seq = 上一次的ack   seq = 2  ack=2

> 如果有一方发送消息 对方没有确认，会重传（丢包了）

> 如果在断开的时候： 客户端发送了最后一次确认消息，但是包丢了 （最后的一次包丢了，服务端会再次发送分手消息） 当客户端发送最终的消息后会等待一段时间， 等到服务端没有在发送消息就关闭掉  （tcp在断开的时候 不会立刻断开 需要等待一会 端口可能会被用尽 http长连接）


## tcp的特点
- 控制数据的传输速度 （滑动窗口， 维护了我要发送的数据）  窗口协商  (用来控制发送速率，保证收支平衡，可以按照顺序来进行数据的重组)
- 滑动窗口的核心（就是保证控住速度，而且有序） 缺点是队头阻塞 （一帧大小 理论值1500 - ip头20个字节  tcp头20个字节） 一般来说超过1460个字节大小的时候就要拆分

- 如果发送数据对方能立即确认， 这个时候发送的速度就取决于网速  慢启动  （就是当我们传输数据的时候出现丢包的情况，就重新会到原点，慢慢发送数据） （如何能减少慢启动的数量）  （快重传可以避免回到原点， 超时重传会回到慢开始）

> （队头阻塞  、 慢开始问题 （快重传））

## 粘包  
- 就是将多个小的包链接在一起  (尽可能减少小包的传递) Nagle算法 最多只能有一个未被确认的小段 （如果确认速度非常快，那么就没有粘包的效果了）
- cork算法 当达到一定值的时候 在统一发送 （达到帧的大小之后统一发送数据）  

> 每一个包都会浪费tcp头部 (整个tcp传输数据的特点)


作业就是整理一下 一个段 从一方发送到另一方发什么了什么


## udp 
面向无连接的 本身没有超时重传没启动，而且适合传递不重要的数据 （也可以在这个基础上来进行 增加重传， 安全） http3 基于udp协议的


