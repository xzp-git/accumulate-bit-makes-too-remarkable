## http1.0

- 每个请求都需要建立一个 tcp 链接
- 三次握手、慢启动问题
- tcp 断开的问题：不会立即断开需要等待一段时间，在关闭 tcp 链接， 占用大量端口，可能会导致端口用尽

## http1.1

> keep-alive

在 1 个 tcp 链接上可以完成多个 http 的事物 （content-length 来区分请求体） 可以复用链接 （没有每次都慢启动）
请求都是串行的 （在同一个 tcp 通道中， 为什么不能是并发？ 因为 http 他没有序号，也就意味着不能重组，响应和请求得有一个映射关系）
管线化，优化串行问题，整批提交 http 请求，响应还是要按照顺序来返回 ， http 的队头阻塞问题 head-of-line-blocking (浏览器没有开启)
1 个域名可以链接多个 tcp 链接 chrome 是 6 个 （并发操作） 带宽竞争 固定的带宽 6 个慢启动 （通过多创建几个域名来解决这些问题，域名多了要做 dns 解析，文件合并，雪碧图，减少请求，如果文件打包到一起，文件太大，下载慢，缓存） http1.1 增加了缓存

> http1.1 虽然增加了 keep-alive (缺点 http 队头阻塞,tcp 队头阻塞问题，不安全明文传输，http 是文本传输协议)

## https

https = http + ssl/tls v3 改名成了 tls (加密，让数据安全的传输)

- 1.数据不能被篡改 （http 无状态的） 将内容进行摘要，到时候校验摘要的内容 (SHA256)
- 2.让传输的数据进行加密

- 加密算法 对称加密 AES 非对称加密 RSA

  - 方案 1： 通过客户端主动发请求来索要密钥， 密钥如果在网络中传输会被截获 （能不能别传递密钥这样不安全）
  - 方案 2: 公钥和私钥 （公钥加密，私钥解密，私钥加密，公钥解密） 服务端和客户端同时产生一对密钥（服务端的私钥和公钥，客户端的私钥个公钥），互相把公钥共享给对方，公钥加密只能私钥解密，如果出现中间人也无法解密内容。 这样就安全了？ 你怎么知道对方是真人？ 我们无法校验公钥的授予方
  - 方案 3： 优化加密方式，服务端生成一对公钥和私钥，将公钥发送给客户端，客户端生成会话密钥，用服务端提供的公钥来进行加密，传输给服务器，服务器可以解密，解密后可以拿到会话密钥，后续的操作可以采用对称加密来通信 （服务端发过来的公钥我不知是不是真的）
  - 证书，证明你是谁，来确定公钥的发送者

  - ca 证书，让公钥变的更信任，第三方可信任的（机构不能造假）服务端生成一对公钥和私钥，将公钥交给第三方机构，他会帮你提供一个证书
    （证书要包含你的“公钥”，有效期，颁发机构信息，摘要用的什么算法） -》 将证书进行一个摘要（内容小）=》 机构也内置了一对密钥 用私钥来加密你的摘要
  - 用户电脑中内置 ca 公钥，ca 来解密，解密后将证书再次摘要，如果两次结果一致，就是可信任的，会通过公钥拿到证书中的公钥

  - 服务端将公钥放到证书中， 证书会做非对称加密，客户端可以（验签）验证证书的来源，如果靠谱则可以去到服务端的公钥
  - 付费： 你要提供一个公钥，交给付费机构，付费机构就会给你个证书，你可以将证书发送给客户端即可

> 采用了对城和非对称 两种方式进行加密，保证公钥是服务端发送的引入了 ca 中

tls 握手
client hello 我有哪些加密的方式（密钥交换的时候用什么方式，对称加密用什么，非对称加密用什么，摘要算法服务端）

- client random -> 服务端
  server hello
- server random -> 给客户端 采用密钥的方式来通信

> 主要的目的就是，告诉对方加密的方式（如果方式固定的话 就不用这次 rtt 了 1.3）

- server 给你一个证书 并且生成一个 params 交给客户端
- client 生成一个 params 交给服务端

- client random + server random + client params + serverParams -> 会话密钥 （后续用于加密内容的也就是做对称加密的密钥）

- “DECHE” 算法 用于交换密钥 密钥交换算法，客户端和服务端通过两个参数 ，可以创建出一个会话密钥来，通过这个会话密钥可以加密内容，虽然参数暴露到了网络中，但是无法通过这两个参数 来计算出这个会话密钥

> tls 握手过程 1） 协商中用到的加密算法 2） 交换密钥参数，生成会话密钥 3） 通过这个会话密钥加密通信

## http2.0

- http1.1 有什么问题？ 纯文本格式 ， 采用\r\n\r\n 来解析内容， 在解析的过程中会有歧义 connect Connect 性能比较差， http 不再采用文本格式，采用纯的二进制的方式来通信
- http1.1 不能乱序收发 ，在请求的时候我们可以将数据直接放到管道中传输（流 stream 二进制帧（流的 id）） 可以直接将不同的请求塞到一个流中传输
- http1.1 要开启多个 tcp 链接 消耗性能
- 多个 tcp 三次握手 慢启动....

http2.0 优化

- 二进制方式传输
- 一个域名只建立一个 tcp 链接，一个链接中可以同时传输不同请求（http 中的队头阻塞问题）， 传输内容考的是流（模型，传递的是帧，帧就是传输的单位）
- 二进制分针层，流量控制，优先级处理，服务端推送
- 头部在 http1.1 中 只能压缩内容 gzip br deflate, cookie(domain path) 固定的字段 content-length host... http2 中做了头部压缩 hpack

- html 1/3 css 1/3 js 1/3 -> 流 如果中间包丢失了 后面需要前面的传递完成后再去重新发送
- 头部压缩 索引表 （动态表，静态表） 哈夫曼编码 （可以让编码的结果没有歧义、而且编码的结果小）

如何编码 让常用的字符编码出的结果短一点 ，让不常用的长一些

编码的问题 a-> 0 b -> 1 c-> 10 d-> 11

a-> 00
b-> 01
c-> 10
d-> 11

6 个字符进行编码 我需要用 111 -》 8 每个字节都得用 3 个位来表示

000
001
010
011
100
111
110
101

46 \* 3 = 138 个位来表示
