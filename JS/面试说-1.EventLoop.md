# 浏览器 EventLoop

事件循环（EventLoop）是 JavaScript 中一种用于处理异步操作的机制。它是 JavaScript 单线程执行模型的核心部分，负责协调和处理任务的执行顺序。
JavaScript 是一门单线程的语言，意味着他只有一个主线程来执行代码。然而，在实际开发中，我们经常会遇到需要处理异步任务的情况，例如网络请求、定时器和事件处理等。为了不阻塞主线程的执行，JavaScript 引入了事件循环机制。

事件循环由以下几个部分组成：

1. 执行栈 （Call Stack）：JS 代码的执行过程会使用一个执行栈来记录函数调用的顺序和位置。当执行一个函数时，他会被推入执行栈，当函数执行完成后，会从执行栈中弹出。
2. 任务队列（Task Queue）：当异步任务完成时，会被放入任务队列中等待执行。常见的异步任务包括定时器回调函数、网络请求的回调函数、事件处理函数等。JavaScript 中的任务队列可以分为宏任务队列和微任务队列。
3. 事件循环（EventLoop）：事件循环是一个持续运行的过程，他不断地检查执行栈和任务队列的状态，并根据一定的规则将任务队列中的任务推入执行栈中执行。

具体来说，事件循环按照以下顺序处理任务：

1. 在 JavaScript 中，主代码块别视为一个宏任务。它是由 JavaScript 引擎执行的最顶层任务。当 JavaScript 文件加载时，引擎会将主代码作为一个整体任务执行。
   在主代码块中，同步代码会被按顺序逐行执行，遇到宏任务或者微任务会把他们分别放入各自的任务队列中等待执行，直到执行栈为空。
2. 执行微任务：当主线程执行完当前宏任务时，事件循环会检查微任务队列。如果微任务队列不为空，他会依次执行所有微任务，直到微任务队列为空。
3. 渲染 UI：如果有需要更新的 UI，事件循环会进行 UI 渲染。
4. 重复循环：事件循环会再次从宏任务队列开始，重复以上步骤。

所以总结一下：
在一次事件循环中，宏任务会先执行，然后在宏任务中产生的微任务会立即执行。当所有微任务执行完毕后，事件循环会再次进入下一个宏任务。
所以，宏任务确实会先执行，但是在宏任务中的微任务会在宏任务执行完毕前立即执行。这样可以确保微任务的及时响应和执行顺序。

> Tips：

- 常见的宏任务
  - setTimeout 和 setInterval：用于在一定时间间隔后执行回调函数。
  - XMLHttpRequest 和 fetch：用于发送网络请求。
  - 事件监听器：例如点击事件、鼠标移动事件等。
- 常见的微任务
  - 使用 Promise 和其相关方法（例如 then 和 catch）创建的微任务。
  - MutationObserver：用于监听 DOM 结构的变化。

# Node 中的事件循环

https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick

当我们在 Node.js 中运行程序时，它遵循一个称为 EventLoop 的事件循环机制。EventLoop 分为几个阶段，每个阶段都有特定的任务和功能。以下是 Node.js 中 EventLoop 的各个阶段：

Timer 阶段：在这个阶段，Node.js 会检查所有已经设置的定时器并执行其回调函数。这些定时器可以是通过 setTimeout()、setInterval()或者 setImmediate()函数设置的。当定时器到期时，它们的回调函数将被调用。

I/O callbacks 阶段：在这个阶段，Node.js 会处理之前被延迟的 I/O 操作的回调函数。这些 I/O 回调函数可以是网络请求、文件操作或其他异步操作的结果。当一个异步操作完成时，它的回调函数会在这个阶段被调用。

Idle, prepare 阶段：这个阶段通常被忽略，不需要关注。

Poll 阶段：在这个阶段，Node.js 会查询操作系统是否有要处理的新的 I/O 事件。如果有新的 I/O 事件需要处理，则它们会被添加到事件队列中，并在下一个阶段被处理。如果没有新的 I/O 事件，Node.js 会等待新的事件到来，并阻塞在这个阶段。

Check 阶段：在这个阶段，Node.js 会执行 setImmediate()函数注册的回调函数。这些回调函数会在当前轮次的事件循环之后立即执行。

Close callbacks 阶段：在这个阶段，Node.js 会执行关闭事件的回调函数，例如 socket 连接断开的回调。这些回调函数会在这个阶段被执行。

在每个阶段之间，Node.js 可以接收新的 I/O 事件并将其添加到事件队列中，以便在下一个阶段被处理。整个事件循环会持续不断地进行，直到程序退出或关闭。
